<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://d3js.org/d3.v5.js" charset="utf-8"></script>
    <script src="map.js" charset="utf-8"></script>
    <title>D3 Map Component</title>
    <style>
        path { fill: none; }
        svg { 
            background-color:none;
            outline: medium solid grey;
        }
        use.stitches {
            stroke: grey;
            stroke-width: 3px;
            fill: none;
        }
        g.territory { stroke: grey; }
    </style>
</head>
<body>
    <svg id="svg-map" width="600" height="700">
        <defs>
            <g id="source">
                <title> Source </title>
                <desc> A glyph representing a source. </desc>
                <circle r="10"></circle>
            </g>
            <g id="sink">
                <title> Sink </title>
                <desc> A glyph representing a sink. </desc>
                <path d="M10,0 H-10 M0,10 V-10"></path>
            </g>
            <!-- modern browsers can use defs in external svg files; we might want to switch to this approach as we accumulate a design library of glyphs! -->
            <!-- Example use : <use x="480" y="250" xlink:href="#sink" fill="none" stroke="#F00" stroke-width="3" /> -->
        </defs>
    </svg>
    <h3 class="coordinates"></h3>
    <h3 class="info"></h3>
    <div width="600">
    <p> An svg based map with a terrain layer and an content layer. The terrain is projected flat,
        and the camera is moved and zoomed using CSS transforms. The content layer is semantically zoomed 
        by moving arond svg glyphs, without scaling them. Conversion from screen to viewport to spherical
        coordinates is handled for the user.
    </p>
    <p> There is some customizable interactivity. In this example moving the mouse gives you the 
        current spherical coordinates. Clicking on a marker reveals the content of the object being
        displayed. In this example, grey stitches were placed at the corners of the SRTM raster tiles the
        terrain contours were computed from.
    </p>
    <p>Elevation data was obtained from an old version of the Shuttle Radar Topography Mission, and the 
        territories displayed were taken from the 2017 US census tracts. The precomputed geometries are
        loaded and displayed asynchronously as they arrive. The displayed glyphs are embedded SVG defs,
        and can be styled with CSS.
    </p>
    </div>
    <script>
        let svg = d3.select("svg#svg-map");
        let coordinates = d3.select(".coordinates");
        let info = d3.select(".info");
        let w = +svg.attr("width");
        let h = +svg.attr("height");
        let pins = [];

        // Mark each intersection of integer longitude and latitude
        for (let x=-120; x<=-114; x++)
            for (let y=35; y<=42; y++)
                pins.push( {x:x, y:y, class:'stitches', glyph:'sink'} );
        // lets me visually check marks and contours have the same projection

        let map = createMap(svg, {} )
            .marks( pins )
            .click( function (mark, index, selection) {
                info.html( JSON.stringify(mark) );
                // I want to stop propagation to the background if user clicks something in the foreground
                d3.event.stopPropagation(); // should I include this by default in a handler wrapper?
            } )
            .move( function() {
                let screen = d3.mouse( this );
                let sphere = map.screen2sphere( screen );
                coordinates.html( sphere );
            });
        map();

        // let elevationScale = d3.scaleLinear()
        //     .range(['#222', '#ddd'])
        //     .domain([-100, 4400]);
        // map.setColorScale( elevationScale );

        // add the prepared 2017 tract data
        d3.json( 'data/2017tractsNV.json' )
            .then( map.addBounds );

        // d3.json( 'elevation/N35W120H00.json' )
        //     .then( map.addContour );
        // meh, just set sea level on the entire sphere rather than rendering the complex geometry resulting from data missing in the SRTM patch!
        map.addContour( {type:"Sphere", value:-1} );
        
        // add the contour data as it loads
        d3.json( 'data/N35W120H500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H1000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H1500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H2000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H2500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H3000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H3500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H4000.json' )
            .then( map.addContour );
    </script>
  
</body>
</html>