<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <!-- <meta name="viewport" content="width=device-width"> -->
    <script src="https://d3js.org/d3.v5.js" charset="utf-8"></script>
    <title>D3 Map Component</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            border: 0;
            font-family: Arial, Helvetica, sans-serif;
        }
        svg#visualization {
            position: absolute;
            height: 100%;
            width: 100%;
        }
        .overlay {
            position: absolute;
            background-color:lightblue;
            padding: 5px;
            border-radius: 5px;
            /* outline: medium solid grey; */
        }
        details { top: 5%; left: 5%; right: 5% }
        .coordinates { bottom: 5%; right: 5%; }
        .info { bottom: 5%; left: 5%; }
        g.territory, use.target {
            stroke: grey;
            stroke-width: 3px;
            fill: none;
        }
        .h4000 { fill: #FFFFFF; }
        .h3500 { fill: #F8F8F8; }
        .h3000 { fill: #EEEEEE; }
        .h2500 { fill: #E8E8E8; }
        .h2000 { fill: #DDDDDD; }
        .h1500 { fill: #D8D8D8; }
        .h1000 { fill: #CCCCCC; }
        .h500 { fill: #C8C8C8; }
        .h0 { fill: #BBBBBB; }
    </style>
</head>
<body>
    <svg id="visualization"
        viewBox="0 0 500 600"
        preserveAspectRatio="xMidYMid meet"
        pointer-events="all">
        <g class="atlas">            
        </g>
        <defs>
            <g id="sink">
                <title> Sink </title>
                <desc> A glyph representing a sink. </desc>
                <path d="M10,0 H-10 M0,10 V-10"></path>
            </g>
        </defs>
    </svg>
    <h4 class="overlay coordinates"></h3>
    <h4 class="overlay info"></h3>
    <details class="overlay">
        <summary>Details</summary>
        <p> An D3 map with a terrain layer and an content layer. The terrain is projected flat,
            and the camera is moved and zoomed using CSS transforms. The content layer is semantically zoomed 
            by moving arond svg glyphs, without scaling them. Conversion from screen to viewport to spherical
            coordinates is handled for the user.
        </p>
        <p> There is some customizable interactivity. In this example moving the mouse gives you the 
            current spherical coordinates. Clicking on a marker reveals the content of the object being
            displayed. In this example, grey stitches were placed at the corners of the SRTM raster tiles the
            terrain contours were computed from.
        </p>
        <p> Elevation data was obtained from an old version of the Shuttle Radar Topography Mission, and the 
            territories displayed were taken from the 2017 US census tracts. The precomputed geometries are
            loaded and displayed asynchronously as they arrive. The displayed glyphs are embedded SVG defs,
            and can be styled with CSS.
        </p>
    </details>
<script type="module">
import Atlas from './container/atlas.js';
import Contour from './component/contour.js';
import Stamp from './component/stamp.js';
import Navigation from './navigation.js';

main();
async function main() {

    let svg = d3.select('svg#visualization > g.atlas');
    let coordinates = d3.select('.coordinates');
    let info = d3.select('.info');

    // Mark each intersection of integer longitude and latitude
    let targets = [];
    for (let x=-120; x<=-114; x++)
        for (let y=35; y<=42; y++)
            targets.push( {lon:x, lat:y, class:'target', glyph:'sink'} );
    // lets me visually check marks and contours have the same projection

    // load the GeoJson census tract features
    let tracts = await d3.json('data/2017tractsNV.json');
    let territory = tracts.features;

    // load elevation contours
    let terrain = [{type:'Sphere', value:0}];
    for (let m=0; m<=4000; m+=500) {
        let elevation = await d3.json(`data/N35W120H${m}.json`);
        terrain.push(elevation);
    }
    //TODO let these load asynchronously then add them to the atlas and refresh!
    
    let state = [
        {classy:'targets', data:targets},
        {classy:'territory', data:territory},
        {classy:'terrain', data:terrain}
    ];

    let atlas = Atlas(svg, {})
        .move( function() {
            let screen = d3.mouse(this);
            let sphere = atlas.screen2sphere(screen);
            let lon = Navigation.degrees2sexagesimal( sphere[0], 'W', 'E' );
            let lat = Navigation.degrees2sexagesimal( sphere[1], 'S', 'N' );
            coordinates.html(`${lat} / ${lon}`);
        });
    atlas
        .addLayer( 'terrain', Contour()
            .projection( atlas.projection() )
            .classifier( d=>`h${d.value}` ) )
        .addLayer( 'territory', Contour()
            .projection( atlas.projection() )
            .classifier( d=>`tract${d.properties.TRACTCE}`) )
        .addLayer( 'targets', Stamp()
            .position( function(d) {return atlas.sphere2screen([d.lon, d.lat]);} )
            .classifier( d=>d.class )
            .glyph( d=>d.glyph )
            .clicker( showInfo ) );

    // the default click action updates the info panel
    function showInfo(d) {
        if(!d || d==undefined)
            return;
        let json = JSON.stringify(d, null, '\t');
        info.html(`<pre>${json}</pre>`);
    }

    atlas(svg, state);
}
// // default color scale for elevation, cribbed from 'https://en.wikipedia.org/wiki/Wikipedia:WikiProject_Maps/Conventions', though there are no given corresponding heights...
    // let color = d3.scaleQuantize()
    //     .range(['#ACD0A5','#94BF8B','#A8C68F','#BDCC96','#D1D7AB','#E1E4B5',//green to tan
    //     '#EFEBC0','#E8E1B6','#DED6A3','#D3CA9D','#CAB982','#C3A76B','#B9985A','#AA8753',//tan to brown
    //     '#AC9A7C','#BAAE9A','#CAC3B8','#E0DED8','#F5F4F2'])// brown to white
    //     .domain([-100, 4400]);
</script>
</body>
</html>