<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <script src="https://d3js.org/d3.v5.js" charset="utf-8"></script>
    <title>D3 Map Component</title>
    <style>
        .overlay {
            position: absolute;
            top: 5%;
            left: 5%;
        }
        path { fill: none; }
        svg { 
            background-color:none;
            outline: medium solid grey;
        }
        use.target {
            stroke: grey;
            stroke-width: 3px;
            fill: none;
        }
        g.territory { stroke: grey; }

        .h4000 { fill: #FFFFFF; }
        .h3500 { fill: #F8F8F8; }
        .h3000 { fill: #EEEEEE; }
        .h2500 { fill: #E8E8E8; }
        .h2000 { fill: #DDDDDD; }
        .h1500 { fill: #D8D8D8; }
        .h1000 { fill: #CCCCCC; }
        .h500 { fill: #C8C8C8; }
        .h0 { fill: #BBBBBB; }
    </style>
</head>
<body>
    <svg id="atlas"
    width="400"
    viewBox="0 0 500 600"
    preserveAspectRatio="xMidYMid meet">
        <defs>
            <g id="source">
                <title> Source </title>
                <desc> A glyph representing a source. </desc>
                <circle r="10"></circle>
            </g>
            <g id="sink">
                <title> Sink </title>
                <desc> A glyph representing a sink. </desc>
                <path d="M10,0 H-10 M0,10 V-10"></path>
            </g>
            <!-- modern browsers can use defs in external svg files; we might want to switch to this approach as we accumulate a design library of glyphs! -->
            <!-- Example use : <use x="480" y="250" xlink:href="#sink" fill="none" stroke="#F00" stroke-width="3" /> -->
        </defs>
    </svg>
    <h3 class="coordinates"></h3>
    <h3 class="info"></h3>
    <details width="600">
        <summary>Details</summary>
        <p> An D3 map with a terrain layer and an content layer. The terrain is projected flat,
            and the camera is moved and zoomed using CSS transforms. The content layer is semantically zoomed 
            by moving arond svg glyphs, without scaling them. Conversion from screen to viewport to spherical
            coordinates is handled for the user.
        </p>
        <p> There is some customizable interactivity. In this example moving the mouse gives you the 
            current spherical coordinates. Clicking on a marker reveals the content of the object being
            displayed. In this example, grey stitches were placed at the corners of the SRTM raster tiles the
            terrain contours were computed from.
        </p>
        <p> Elevation data was obtained from an old version of the Shuttle Radar Topography Mission, and the 
            territories displayed were taken from the 2017 US census tracts. The precomputed geometries are
            loaded and displayed asynchronously as they arrive. The displayed glyphs are embedded SVG defs,
            and can be styled with CSS.
        </p>
    </details>
<script type="module">
import Atlas from './container/atlas.js';
import Contour from './component/contour.js';
import Stamp from './component/stamp.js';
import Navigation from './navigation.js';

main();
async function main() {

    let svg = d3.select('svg#atlas');
    let coordinates = d3.select('.coordinates');
    let info = d3.select('.info');

    // Mark each intersection of integer longitude and latitude
    let targets = [];
    for (let x=-120; x<=-114; x++)
        for (let y=35; y<=42; y++)
            targets.push( {lon:x, lat:y, class:'target', glyph:'sink'} );
    // lets me visually check marks and contours have the same projection

    // load the GeoJson census tract features
    let tracts = await d3.json('data/2017tractsNV.json');

    // load elevation contours
    let terrain = [{type:'Sphere', value:0}];
    for (let m=0; m<=4000; m+=500) {
        let elevation = await d3.json(`data/N35W120H${m}.json`);
        terrain.push(elevation);
    }
    
    let state = [targets];//[targets, tracts, terrain];
    // need to properly structure state! [{class:...,data:...},...]?

    let atlas = Atlas(svg, {})
        .move( function() {
            let screen = d3.mouse(this);
            let sphere = atlas.screen2sphere(screen);
            let lon = Navigation.degrees2sexagesimal( sphere[0], 'W', 'E' );
            let lat = Navigation.degrees2sexagesimal( sphere[1], 'S', 'N' );
            coordinates.html(`${lat} / ${lon}`);
        });
    atlas
        // .addLayer( 'terrain', Contour()
        //     .projection( atlas.projection() )
        //     .classifier( d=>`h${d.value}` ) )
        // .addLayer( 'territory', Contour()
        //     .projection( atlas.projection() )
        //     .classifier( d=>`tract${d.properties.TRACTCE}`) )
        .addLayer( 'targets', Stamp()
            .transform( atlas.projection() )
            .classifier( d=>d.class )
            .glyph( d=>d.glyph )
            .clicker( showInfo ) );

    // the default click action updates the info panel
    function showInfo(d) {
        if(!d || d==undefined)
            return;
        let json = JSON.stringify(d, null, '\t');
        info.html(`<pre>${json}</pre>`);
    }

    atlas(svg, state);
}

</script>
    <!-- <script type="module" >
        import Atlas from './map.js';
        let svg = d3.select("svg#svg-map");
        let coordinates = d3.select(".coordinates");
        let info = d3.select(".info");
        let w = +svg.attr("width");
        let h = +svg.attr("height");
        let pins = [];

        // Mark each intersection of integer longitude and latitude
        for (let x=-120; x<=-114; x++)
            for (let y=35; y<=42; y++)
                pins.push( {lon:x, lat:y, class:'stitches', glyph:'sink'} );
        // lets me visually check marks and contours have the same projection

        let map = Atlas(svg, {} )
            .tracks( pins )
            .click( function (mark, index, selection) {
                info.html( JSON.stringify(mark) );
                // I want to stop propagation to the background if user clicks something in the foreground
                d3.event.stopPropagation(); // should I include this by default in a handler wrapper?
            } )
            .move( function() {
                let screen = d3.mouse( this );
                let sphere = map.screen2sphere( screen );
                coordinates.html( sphere );
            });
        map();

        // let elevationScale = d3.scaleLinear()
        //     .range(['#222', '#ddd'])
        //     .domain([-100, 4400]);
        // map.setColorScale( elevationScale );

        // add the prepared 2017 tract data
        d3.json( 'data/2017tractsNV.json' )
            .then( map.addBounds );

        // d3.json( 'elevation/N35W120H00.json' )
        //     .then( map.addContour );
        // meh, just set sea level on the entire sphere rather than rendering the complex geometry resulting from data missing in the SRTM patch!
        map.addContour( {type:"Sphere", value:-1} );
        
        // add the contour data as it loads
        d3.json( 'data/N35W120H500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H1000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H1500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H2000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H2500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H3000.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H3500.json' )
            .then( map.addContour );
        d3.json( 'data/N35W120H4000.json' )
            .then( map.addContour );
    </script> -->
  
</body>
</html>